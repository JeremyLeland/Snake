<style>
  body { margin: 0 }
  svg  { width: 100%; height: 100% }

  .message {
    position: absolute;
    bottom: 50%;
    width: 100%;
    text-align: center;
    font-family: sans-serif;
    font-size: 50;
  }

  .snake { stroke: black; stroke-width: 2; }
  .apple { fill: red; stroke: black; stroke-width: 2; }

  .goalForce { stroke: gray; stroke-width: 2; visibility: hidden; }
  .avoidForce { stroke: black; visibility: hidden; }
  .finalForce { stroke: green; stroke-width: 3; visibility: hidden; }
</style>

<body>
</body>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
<script type="module">

  import { Snake, Apple } from './SnakeGame.js';

  const Settings = {
    GoalWeight: 0.5,
    AvoidWeight: 100,
    AvoidPower: 1,
    DrawForces: false,
    MinimumAppleDist: 20,
  };


  const SVGNS = 'http://www.w3.org/2000/svg';
  const svg = document.createElementNS( SVGNS, 'svg' );
  document.body.appendChild( svg );


  const State = { Playing: 1, Win: 2, Lose: 3 };

  let snakes = [];
  let apples = [];
  let gameState = State.Playing;
  const gameMessage = document.body.appendChild( document.createElement( 'div' ) );
  gameMessage.className = 'message';

  function spawnSnake() {
    const snake = new Snake( 
      Math.random() * window.innerWidth, 
      Math.random() * window.innerHeight,
      Math.random() * Math.PI * 2
    );
    
    svg.appendChild( snake.bodySVG );
    svg.appendChild( snake.forcesSVG );
    
    snakes.push( snake );
  }

  function spawnApple() {
    const apple = new Apple( 
      Math.random() * window.innerWidth, 
      Math.random() * window.innerHeight,
    );

    svg.appendChild( apple.svg );

    apples.push( apple );
  }

  spawnSnake();
  let player = snakes[ 0 ];
  setTimeout( spawnSnake, 2000 );
  setTimeout( spawnSnake, 4000 );
  

  spawnApple();
  spawnApple();
  spawnApple();
  setInterval( spawnApple, 3000 );

  function update( dt ) {
    snakes.forEach( snake => {
      apples = apples.filter( apple => {
        if ( snake.distanceTo( apple ) < snake.size + apple.size ) {
          snake.maxLength += 100;
          apple.destroy();
          return false;
        }

        return true;
      } );

      const vectors = snake.getVectors( snakes );

      snake.isAlive &= vectors.every( vector => vector.dist > 0 );

      if ( snake == player ) {
        const towardMouse = Math.atan2( mouseY - snake.y, mouseX - snake.x );
        snake.turnTowardAngle( towardMouse, dt );
      }
      else {
        // Head towards nearest apple we can hit (not too close)
        // TODO: Remember our heading so we don't steer away from apples when we get close?
        let closest = apples.map( 
          apple => ( { apple: apple, dist: snake.distanceTo( apple ) } )
        ).reduce( 
          ( acc, appleDist ) => 
            Settings.MinimumAppleDist < appleDist.dist && appleDist.dist < acc.dist ? appleDist : acc,
          { apple: null, dist: Infinity }
        );

        const goalX = closest.apple?.x ?? snake.wanderX;
        const goalY = closest.apple?.y ?? snake.wanderY;

        // Try to avoid other snakes
        const weighted = vectors.map( vector => {
          const weightedDist = Math.abs( Settings.AvoidWeight / Math.pow( vector.dist, Settings.AvoidPower ) );
          return { 
            x: Math.cos( vector.angle ) * weightedDist / vectors.length,
            y: Math.sin( vector.angle ) * weightedDist / vectors.length
          };
        } );

        snake.drawAvoidForces( weighted );

        const goalAngle = Math.atan2( goalY - snake.y, goalX - snake.x );
        const goalForce = {
          x: Settings.GoalWeight * Math.cos( goalAngle ), 
          y: Settings.GoalWeight * Math.sin( goalAngle ),
        }

        snake.drawGoalForce( goalForce );

        const finalForce = weighted.reduce(
          ( acc, wv ) => ( { x: acc.x + wv.x, y: acc.y + wv.y } ),
          goalForce
        );
        snake.drawFinalForce( finalForce );

        const finalAngle = Math.atan2( finalForce.y, finalForce.x );
        snake.turnTowardAngle( finalAngle, dt );
      }
    } );

    snakes = snakes.filter( snake => snake.moveForward( dt ) );

    if ( snakes.length == 1 && snakes[0] == player ) {
      gameMessage.innerText = 'Win!';
    }
    else if ( !snakes.includes( player ) ) {
      gameMessage.innerText = 'Lose!';
    }
  }


  // const gui = new dat.GUI();
  // gui.width = 200;
  // for ( const setting in Settings ) {
  //   gui.add( Settings, setting );
  // }

  let mouseX = 0, mouseY = 0;
  document.onmousemove = onInput;
  document.ontouchstart = onInput;
  document.ontouchmove = onInput;
  function onInput( e ) {
    const event = e.touches ? e.touches[0] : e;
    mouseX = event.pageX;
    mouseY = event.pageY;
  }

  let keyDown = true;     // default to running
  document.onkeydown = () => keyDown = true;
  document.onkeyup   = () => keyDown = false;

  let lastTime = null;
  function animate( now ) {
    lastTime ??= now;   // for first call only

    // Only update when key is pressed (for debugging purposes)
    if ( keyDown ) {
      update( now - lastTime );
    }
    lastTime = now;

    requestAnimationFrame( animate );
  }
  requestAnimationFrame( animate );


</script>